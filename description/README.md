Для внутренней реализации игры создаётся некоторое количество классов, которые опишем ниже. Для всех них, за исключением только класса Step, в файлах-хедерах приведены подробные комментарии, говорящие что делает данный метод / содержит данное поле, поэтому здесь будет только кратко рассказаны идеи и межклассовое взаимодействие (на высоком уровне).

TypeOfStep не является классом, но содержит в себе некоторое количество типов и функций, которые удобно описывают основные характеристики игры. Его единственный недостаток в том, что он был создан достаточно поздно, из-за чего большинство других классов не поддерживают или поддерживают только во внешнем взаимодействии его функционал. Pair - название типа, содержащего два int, который используется для обозначения клетки поля. В файле-хедере указано правило создания такого поля, поэтому только по значениям можно определить, к какому из трёх типов принадлежит данная клетка: фигура-клетка (клетки, по которым двигаются фишки в процессе игры), стена-клетка (клетки, в которых части стены перегораживают фишкам дорогу), перекрёсток-клетка (клетки, которые соединяют две части стены). Для этого определения реализованы три функции. Далее реализованы несколько enum (StepTypeValue, Direction, HVDirection) для удобства обозначения некототорых характеристик. Реализована CardOfStep - структура, содержащая максимально полную информацию о выполняемом в данный момент ходе. Для неё скорректированы методы классов Table и Step, отвечающие за ход игры.

Table - класс, отвечающий за внутреннюю логику поля. Практически не был изменён с версии, созданной до реализации графики, из-за чего некоторые применяемые принципы устарели. Может быть переделан практически независимо от других классов, но такая работа займёт очень много времени. Поэтому под новые требования были переделаны лишь функции, отвечающие за ход, и то лишь во внешнем взаимодействии.
Для данного класса выбирается тип (square), которым реализутся клетки поля, которые включают и клетки со стенками, и клетки с фигурками/фишками. Для этого типа создаются несколько константных названий (FigureType), обознающих, что находится в клетке. Само поле (field) представляет собой двумерный массив, который включает обычные клетки, клетки для стенок и перекрестья. Хранятся реальный размер поля (field_sizes), размер поля только из клеток для фигур (field_figure_sizes) (гарантируется, что квадратное поле, с нечётной стороной квадрата, на котором уместятся четыре фишки), и размер поля из перекрестий (field_wall_sizes). Так как внутренне двумерный массив является на самом деле одномерным, реализовано несколько методов at, позволяющих получить ссылку на клетку поля, с помощью двух координат, а также с помощью двух координат и нескольких смещений. Есть конструктор от длины (= ширины) поля - здесь имеется в виду размер в привычном понимании, то есть field_figure_sizes. Есть метод spawn_figures - установить фигуры на поле.
Далее соответвенно четыре метода ходов. go_figure: переместить фигуру в этой клетке (int, int) в этом направлении (Direction). install_wall: установить стенку через это перекрестье (int, int) вертикально или горизонтально (HVDirection). И два метода, разрешающие конфликтные ситуации: avoid_figure_opponent: перепрыгнуть фигуру противника из этой клетки в этом направлении; avoid_figure_and_barrier: перепрыгнуть фигуру противника вбок, если прямой путь закрыт, последнее Direction (left или right) отвечает за левый или правый "бок" относительно направления столкновения. При некорректном использовании этих методов программа либо падает (assert), гарантируется, что такую ошибку нельзя создать в процессе игры, либо возвращает false, в таком случае гарантируется, что ничего не изменилось, в случае успеха выполняет ход и возвращает true. Имеется в виду, что все принимаемые и возвращаемые значения участвуют в обмене в качестве полей карточки.

Participant не изменялся с момента создания, поэтому далее приводится старое его описание, по-прежнему актуальное.
Participant содержит поля: количество стенок (гарантируется, что неотрицательно) (number_of_walls) и две координаты расположения собственной фигуры (корректность координат проверяется вне класса) (vertical_coordinate, horizontal_coordinate). Методы: конструктор от трёх данных параметров, вывести всю информацию об экземпляре класса (print_all_information), получить внутренние данные (know), использовать одну стенку (уменьшает количество стенок на одну) (use_one_wall) и изменить координаты на данные (change_coordinates).

TableImage отвечает за графическую часть поля. Умеет обрабатывать сигналы о выполнении хода и передавать их далее, изменять своё состояние. При этом игровая логика перемещения фишек ему неизвестна, за это отвечает класс Table, который через посредников и передаёт ему параметры. Практически весь код основан на графической библиотеке gtkmm.
Публичной является главная коробка со всеми кнопками (кнопка является клеткой игрового поля). Это сделано для того, чтобы другие классы могли спокойно конструировать эту коробку для вывода на экран. Значения размеров игрового поля совпадают с классом Table. Далее идут два вектора: коробки для хранения строк кнопок и сами кнопки (= клетки игрового поля). size_of_figure_button - размер в пикселях клетки, в которой располагается фишка (фигура). Поддерживает лишь конечный набор значений, с учётом предусмотренных размеров изображений. Должна указываться при конструировании игры, что позволяет собрать поле максимального размера, вмещающееся на экран. Далее идёт вектор изображений, собирающийся с учётом предыдущей константы. Все изображения находятся в директории image. После обнаружения следующей проблемы: при некоторых расположениях фигур на игровом поле, часть изображений пропадает - проверено, что эта проблема не является внешней, для её понимания нужно лезть во внутреннюю реализацию графической библиотеки - добавлено поле m_Vector_Image_Figure_CssProvider - оно раскрашивает клетку фишки в цвет самой фишки, и при временной потере изображения игра может спокойно продолжаться. Такие же цвета были предусмотрены ранее для клеток стенок, поэтому вынесены отдельно: m_CssProvider_Wall_White, m_CssProvider_Wall_Black.
Несколько следующих методов являются вспомогательными для конструирования игрового поля. Затем идут функции обработки сигналов: содержится экземпляр класса ProcessingSignals (слабый указатель на него), который при срабатывании нажатия на кнопку обработает этот сигнал и передаст для дальнейшей обработки другим классам. Гарантируется, что любой ход не сломает программу: либо будет выведено указание игроку, либо выполнится ход. Затем идёт сам конструктор с параметрами число игроков, размер поля, размеры клетки. И два метода изменения ситуации на игровом поле: переставить фигуру и поставить элемент стены.

AllImage является надстройкой над TableImage, поэтому и содержит умный указатель на него. Притом публично, то есть к его методам (TableImage) можно обращаться извне. Следующие поля: несколько коробок для демонстрации хранимых объектов, самая главная по аналогичным TableImage причинам публичная. Затем векторы, содержащие радио кнопки - это кнопки, позволяющие выбрать, какой тип хода в данный момент совершает игрок, рамки и строки - это выводимый о состоянии игроков текст. Конструктор от числа игроков, размеров поля, размера клетки с фишкой, и количества стенок у одного игрока. Метод radio_button_on_signal_clicked, отлавливающий (то есть он вызывается) изменение выбранной радио кнопки. В любой момент времени может быть выбрана ровно одна радио кнопка. change_condition_of_player - метод, изменяющий состояние игрока (надпись об этом состоянии). Вся информация передаётся ему в качестве параметров, сам AllImage не помнит данные об игроках.

ProcessingSignals - класс, отвечающий за обработку сигналов. Содержит указатель на класс Step, внутри которого создаётся. Указатель было решено сделать сырым, по тем причинам, что он передаётся изнутри класса, который возможно не хотелось бы создавать через shared_ptr, не несёт никакой ответственности за объект, на который ссылается, нужен лишь для того, чтобы передать информацию на самый верх иерархии.Вместе с TableImage, AllImage, Step образует кольцевую схему взаимодействия: два графических класса ловят сигналы, в примитивном виде передают их ProcessingSignals, он преобразует их уже в вид цельной команды и передаёт Step для дальнейшей обработки и передачи указаний всем классам проекта. Поля и методы предназначены ровно для этих целей, так как отдельные сигналы содержат лишь часть информации о команде, то он хранит уже полученные данные, и когда их достаточно для цельной команды, он передаёт её вверх и сбрасывает часть настроек.

Step - самый главный класс игры, существенно переделан с предыдущей версии, связывает воедино все компоненты системы. Хранит в себе умные указатели на все предыдущие классы, за исключением лишь тех, которые уже спрятаны в другие классы (TableImage в AllImage, например). Есть конструктор от числа игроков, размеров поля, количества стенок у одного игрока и размера клетки с фишкой. distributor - метод, вызываемый в ProcessingSignals, который переводит информацию о выполняемом ходе из примитивной (номер типа хода, одна или две клетки игрового поля) в вызов конкретных методов с требуемыми параметрами. relation_pair_2_to_pair_1 - вспомогательная функция, сообщающая положение одной клетки относительно другой. Для простых положений выдаёт логичный ответ (если клетки соседние, то ответ соответсвует ожиданию), но корректно обрабатывает всевозможные ситуации, при этом более-менее разумно, именно так будет выбран ход, если нажатие клеток не совсем корректно. Для ситуаций, в которых трудно придумать разумную обработку, в карточку игрока записывается, что ход был сделан с ошибкой и больше ничего не происходит. При исправлении эта надпись убирается (это реализовано внутри AllImage и из Step передаётся в качестве параметра). next_number_of_player - метод, указыающий, какой игрок ходит после данного. Далее идут четыре метода хода и один вспомогательный для избежания дублирования кода.

Show - достаточно простой класс, отображающий графику на экран. Написан по gtkmm. Выводит игру на экран, при закрытии окна с игрой завершает работу.

При работе над проектом использовались следующие паттерны. Mediator (в роли которого выступает Step), Bridge (между практически всеми взаимодействующими классами, хотя, возможно, не идеально) - есть несколько требований сверху для объектов, вся остальная реализация целиком зависит от объекта. Частично применялись идеи из других паттернов.
